#!/bin/bash
#
# Copyright (C) 2012, Christopher A. Snapp <snappca@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# enable unbound variable checking
set -u

# os check
[[ "$(uname -s)" != 'SunOS' ]] || { echo 'ERROR: this script is known not to work on Solaris'; exit 1; }

# dependency check
[[ "$(which expect)" ]] || { echo 'ERROR: expect command is not available'; exit 1; }

prog='ssh-exec'
version=12.01
username="$USER"
concurrency=1
output_file=/dev/null
output_dir=
commands=
login_password_pattern='#null#'
root_password_pattern='#null#'
sudo_password_pattern='#null#'
password_patterns=( )
password_prompts=( )
hosts=( )
interactive=false
password_auth=false
debug=false
quiet=false
silent=false
verbose=false
ssh_agent=true
load_ssh_agent=false
su=false
sudo=false

recipes_dir="$HOME/.ssh-exec"

tmp_dir="$(mktemp -dt $prog.XXXXX)" || error 'cannot create temp directory!'
script="${tmp_dir}/commands.exp"

trap 'rm -rf $tmp_dir; rmdir $output_dir 2>/dev/null; $load_ssh_agent && ssh_agent_destroy; exit;' EXIT
trap 'stty echo; cat $tmp_dir/*.{running,log} 2>/dev/null; echo -e "\nAborted!" >&2; rm -rf $tmp_dir; jobs -p | xargs kill 2>/dev/null; $load_ssh_agent && ssh_agent_destroy; exit;' INT TERM

# initialize expect script used during ssh session
cat > "$script" <<'EXPECT'
#!/usr/bin/expect
set timeout 20
set prompt "(>|%|#|\\$) (\x1B.*)*$"
set root_prompt "# (\x1B.*)*$"
set username "#username#"
set host "#host#"
set root_password "#password1#"
set sudo_password "#password2#"
set login_password "#password3#"

log_user 0

spawn -noecho ssh $username@$host
set connected 1

expect_after {
    timeout {
        send_user "\n\n                   #  Aborted! - Timeout Looking for Prompt: $host  #\n"
        exit 1
    } default {
        send_user "\n\n                   #  Aborted! - Error State Observed: $host  #\n"
        exit 1
    }
}

expect "*nter passphrase" {
    send_user "\n\n                   #  Aborted! - Missing Passphrase: $host  #\n"
    return
} "*denied" {
    send_user "\n\n                   #  Aborted! - Permission Denied: $host  #\n"
    return
} "*yes/no" {
    send_user "\n\n                   # Accepting Authenticity: $host #\n"
    send "yes\r"
    expect -re $prompt {
        send_user "\n\n                   #       Connect:     $host       #\n"
        send "\r"
        log_user 1
    }
} "*ssword:" {
    if {"$login_password" == "#null#"} {
        send_user "\n\n                   #  Aborted! - No Login Password Available: $host  #\n"
        return
    }

    send "$login_password\r"
    expect -re $prompt {
        send_user "\n\n                   #       Connect:     $host       #\n"
        send "\r"
        log_user 1
    } "*ssword:" {
        send_user "\n\n                   #  Aborted! - Invalid Login Password: $host  #\n"
        return
    }
} -re $prompt {
    send_user "\n\n                   #       Connect:     $host       #\n"
    send "\r"
    log_user 1
}

if {"$root_password" != "#null#"} {
    send "su -\r"
    expect "*sword:" {
        send "$root_password\r"
        expect "*sword" {
            send "exit\r"
            send_user "\n\n                   #  Aborted! - Invalid Root Password: $host  #\n"
            exit 2
        } -re $root_prompt {
            # send ctrl-c to force a prompt
            send \003
        }
    }
}

if {"$sudo_password" != "#null#"} {
    send "sudo su - root\r"
    expect "sword*" {
        send "$sudo_password\r"
        expect "*sword" {
            # send ctrl-c to force a prompt
            send \003
            send "exit\r"
            send_user "\n\n                   #  Aborted! - Invalid SUDO Password: $host  #\n"
            exit 2
        } -re $root_prompt {
            # send ctrl-c to force a prompt
            send \003
        }
    } -re $root_prompt {
        # send ctrl-c to force a prompt
        send \003
    }
}

#COMMANDS#

if {"$root_password" != "#null#" || "$sudo_password" != "#null#"} {
    expect -re $prompt {
        log_user 0
        # exiting root session
        send "exit\r"
    }
}

if {$connected} {
    expect -re $prompt
    log_user 0
    send "exit\r"
    send_user "\n\n                   #       Disconnect:  $host       #\n"
}
EXPECT

# print command usage
#
# $1 - boolean determining if full formatted output should be printed
print_usage () {
    local verbose b c u

    verbose=false

    # initialize formatting variables
    b=
    c=
    u=

    if [[ $# -gt 0 ]]; then
        verbose=true

        if [[ "$1" == 'pretty' ]]; then
            b='\033[1m'
            c='\033[0m'
            u='\033[4m'
        fi
    fi

    if $verbose; then
        echo "$prog $version" | tr '[:lower:]' '[:upper:]'
        echo
        echo -e "${b}NAME${c}"
        echo -e "    ${b}$prog${c} - executes commands on a list of remote hosts; optionally as root"
        echo
    fi

    echo -e "${b}SYNOPSIS${c}"
    echo -e "    ${b}$prog${c} [${b}-hioOpPrR${c}] [${b}--help${c}] [${b}-c${c} ${u}count${c}] [${b}-f${c} ${u}commands-file${c}] [${b}-F${c} ${u}hosts-file${c}] [${b}-u${c} ${u}username${c}] ${u}host1 host2 host3...${c}"
    echo

    if $verbose; then
        echo -e "${b}DESCRIPTION${c}"
        echo -e "    $prog provides a secure method for automating the execution of scripts"
        echo -e "    on multiple remote hosts.  The automation can be set to either increment"
        echo -e "    through the list of hosts or run against multiple hosts concurrently."
        echo
        echo -e "    Other methods exist for running scripts against remote hosts but they tend"
        echo -e "    to require the installation of a daemon on each remote host (e.g. Func)."
        echo
        echo -e "    By comparison, $prog is a simple wrapper for standard SSH transactions."
        echo -e "    This means there are NO server side modifications required and all"
        echo -e "    automated scripts are tracked the same as if you had logged into each"
        echo -e "    system and performed the commands manually.  This is in contrast to Func's"
        echo -e "    approach where all commands are executed by a privileged 'func' user and"
        echo -e "    proper accountability is lost."
        echo
        echo -e "    ${b}Password Handling${c}"
        echo -e "    In order for $prog to accomplish password handling across numerous hosts"
        echo -e "    it expects a simple convention to be followed.  This convention allows for"
        echo -e "    you to keep different passwords on all of your systems while keeping it"
        echo -e "    easy to manage."
        echo
        echo -e "    ${b}Password Patterns${c}"
        echo -e "    If the password you have provided contains the letter 'X' (upper or lower"
        echo -e "    case) immediately followed by a digit then the 'X + digit' combination"
        echo -e "    shall be substituted with the letter from the hostname identified by the"
        echo -e "    digit with the case dictated by the case of the letter 'X'."
        echo
        echo -e "    NOTE:"
        echo -e "      * The letter 'X' is perfectly valid as part of a password; it is ONLY"
        echo -e "        when the letter 'X' is IMMEDIATELY followed by a digit that the"
        echo -e "        substitution takes place."
        echo -e "      * If your password pattern does not contain any 'X + digit' combinations"
        echo -e "        then the password will be unaltered as it is submitted to each host."
        echo -e "      * Only the first digit immediately following the letter 'X' is used during"
        echo -e "        character substitution."
        echo -e "      * Character substitution occurs as if you were typing the password in"
        echo -e "        directly; that is, if the character retrieved from the hostname"
        echo -e "        is either a digit, period, or hyphen AND the case indicated by the"
        echo -e "        letter 'X' is uppercase, then the result would be the same as if you"
        echo -e "        pressed the 'shift' key while typing the digit, period, or hyphen."
        echo
        echo -e "    Examples (where hostname is 'example.com'):"
        echo -e "            pattern: ${b}X1x2X3x4X5${c}    result: ${b}ExAmP${c}"
        echo -e "            pattern: ${b}fooX3barX1x4${c}  result: ${b}fooAbarEm${c}"
        echo -e "            pattern: ${b}foobarX1x8${c}    result: ${b}foobarE>${c}"
        echo -e "            pattern: ${b}fooXbarX1x12${c}  result: ${b}fooXbarEe2${c}"
        echo
        echo -e "    ${b}Timeouts${c}"
        echo -e "    $prog expects that each command within your script results in a prompt."
        echo
        echo -e "    A prompt is recognized by the regular expression:"
        echo
        echo -e "            ${b}/(>|%|#|\\$) \$/${c}"
        echo
        echo -e "    Should a command not return to a prompt within the timeout period (default"
        echo -e "    is 20 seconds) then $prog will abort execution of your script against"
        echo -e "    that host."
        echo
        echo -e "    ${b}Tokens${c}"
        echo -e "    $prog tokens are identified by the hash (#) mark and are used for two"
        echo -e "    purposes:"
        echo -e "        1. Control underlying expect functionality"
        echo -e "        2. Identify a custom recipe"
        echo
        echo -e "    ${b}Recipes${c}"
        echo -e "    Recipes are custom add-ons created by you to be used as shortcuts to execute"
        echo -e "    common tasks."
        echo
        echo -e "    In order to create a recipe you first need to create the ~/.$prog"
        echo -e "    directory."
        echo -e "    Each filename within this directory is an identifier for a custom token."
        echo -e "    You can put any script that you would normally type into $prog's stdin"
        echo -e "    into a file and then use the token syntax to reference it."
        echo
        echo -e "    You can pass arguments to your recipes by using \$arg# syntax (e.g. \$arg1,"
        echo -e "    \$arg2..etc.) when creating your recipe.  Then when you call your recipe via"
        echo -e "    a token, your args are space delimited within your token tag."
        echo
        echo -e "    NOTE: recipes can contain other recipes"
        echo
        echo -e "    Example:"
        echo -e "        # create the recipe #"
        echo -e "        ~/.$prog/changelog contains:"
        echo -e "            echo -e \"\$(date +%Y%m%d) \$arg1 \$arg2\" >> /var/adm/changelog*"
        echo
        echo -e "        # call the recipe #"
        echo -e "        $prog example.com <<'EOF'"
        echo -e "        #changelog cas \"here is arg2's content\"#"
        echo -e "        EOF"
    fi

    echo -e "${b}OPTIONS${c}"
    echo -e "    ${b}-c${c} ${u}count${c}"
    echo -e "        the number of jobs to run concurrently; default is 10 if no value is"
    echo -e "        provided"
    echo

    if $verbose; then
        echo -e "        NOTE: While the script will execute in separate threads up to the"
        echo -e "              concurrency level you provide, the results will always be"
        echo -e "              returned in the order that you originally specified."
        echo
    fi

    echo -e "    ${b}-d${c}  enable debug mode (print ALL output)"
    echo
    echo -e "    ${b}-f${c} ${u}file${c}"
    echo -e "        the file containing commands to be executed"
    echo
    echo -e "    ${b}-F${c} ${u}file${c}"
    echo -e "        the file containing hosts to be executed against"
    echo
    echo -e "    ${b}-h${c}  display this help and exit"
    echo
    echo -e "    ${b}--help${c}  display formatted help and exit"
    echo
    echo -e "    ${b}-i${c}  convenience mechanism equivalent to passing '#interact#'"

    if $verbose; then
        echo -e "        NOTE: No other commands will be read if this argument is used."
        echo -e "              Additionally, this argument is mutually exclusive with"
        echo -e "              -c, -o, and -O."
    fi

    echo
    echo -e "    ${b}-o${c}  log each system's output to a timestamped file (i.e. ~/ssh-exec.20120131_105929)"
    echo
    echo -e "    ${b}-O${c}  log each system's output to a separate file within a datestamped directory"
    echo -e "        the naming format will be (i.e. ~/ssh-exec.20120131)"
    echo
    echo -e "    ${b}-q${c}  enable quiet mode (only prints job status to screen)"
    echo
    echo -e "    ${b}-Q${c}  enable silent mode (no printing of any output to screen)"
    echo
    echo -e "    ${b}-r${c}  run commands as root via 'su -' authentication"
    echo
    echo -e "    ${b}-R${c}  run commands as root via 'sudo su - root' authentication"

    if $verbose; then
        echo -e "        NOTE: You will be prompted for the password necessary for sudo to"
        echo -e "              execute."
        echo -e "              This password will only be used if the server prompts for it."
        echo -e "              This means that if you have NOPASSWD:ALL set in the sudoers file"
        echo -e "              you could simply hit 'Enter' when prompted and no password will"
        echo -e "              be required."
    fi

    echo
    echo -e "    ${b}-u${c} ${u}username${c}"
    echo -e "        the username used during initial ssh login; default is your current"
    echo -e "        username"
    echo
    echo -e "    ${b}-v${c}  display version information and exit"
    echo
    echo -e "    ${b}-V${c}  enable verbose output"
    echo
    echo -e "    ${b}-p${c}  prompt for user password; allows for a fallback if key login fails"
    echo
    echo -e "    ${b}-P${c}  prompt for user password; disables spawning of ssh-agent"
    echo
    echo -e "${b}WARNING${c}"
    echo -e "    ${b}$prog is only responsible for establishing the connection and${c}"
    echo -e "    ${b}executing the commands you supplied it in the same way as if${c}"
    echo -e "    ${b}you had manually ssh'd in and were typing the commands by hand.${c}"
    echo
    echo -e "    ${b}There is NO special handling of the commands on the server side to${c}"
    echo -e "    ${b}account for OS, distribution, or any other required environment${c}"
    echo -e "    ${b}setup.${c}"
    echo
    echo -e "    ${b}It is YOUR responsibility to ensure the commands will function${c}"
    echo -e "    ${b}on each of the hosts provided.${c}"
    echo

    if $verbose; then
        echo
        echo -e "${b}BUILT-IN TOKENS${c}"
        echo -e "    ${b}#passwd ${u}<username>${c}${b}#${c}"
        echo -e "        Inserts the commands for changing the provided username's password."
        echo -e "        If no username is provided, user will default to root."
        echo
        echo -e "    ${b}#expect ${u}pattern${c}${b}#${c}"
        echo -e "        Explicitly look for a phrase using expect format prior to executing"
        echo -e "        the next command."
        echo
        echo -e "    ${b}#interact#${c}"
        echo -e "        This will pause automatic execution and allow you to execute commands"
        echo -e "        directly into the console.  When you are finished and would like to"
        echo -e "        give control back to automatic execution, simply type #x"
        echo
        echo -e "        NOTE:"
        echo -e "            * You can pass ONE argument to the interact token, which is useful"
        echo -e "              for executing a command just prior to entering interactive mode."
        echo
        echo -e "            * You can use #interact# multiple times within the same script to"
        echo -e "              interleave automated script execution with interactive sessions."
        echo
        echo -e "    ${b}#password${u}:<repeat>:<prompt contents>${c}${b}#${c}"
        echo -e "        This token allows you to securely collect password patterns prior to"
        echo -e "        runtime and then have them injected the number of times specified"
        echo -e "        via the second argument."
        echo -e "        A custom prompt can also be provided as the third argument."
        echo
        echo -e "    ${b}#timeout ${u}duration${c}${b}#${c}"
        echo -e "        Override the default 20 second timeout that expect uses waiting"
        echo -e "        for a prompt."
        echo -e "        Timeout is in seconds; while a value of -1 represents unlimited"
        echo -e "        If no value is provided timeout will be reset to 20 seconds"
        echo
        echo -e "    ${b}#user#${c}"
        echo -e "        inserts the username that $prog is logging in as"
        echo
        echo -e "${b}EXAMPLES${c} - (examples are based on execution within a BASH shell)"
        echo -e "    ${b}Executing simple one liners${c}"
        echo -e "    For very simple scripts you can just use a here-string (i.e. <<<)"
        echo
        echo -e "        $prog example.com <<<'ls -la ~/.ssh'"
        echo
        echo -e "    ${b}Executing multi-line scripts${c}"
        echo -e "    For more complex scripts you can simply hit enter and type your script"
        echo -e "    contents directly into STDIN followed by ctrl-d to finish."
        echo
        echo -e "    If you would like to store your script within your shell's history you"
        echo -e "    would probably rather use a here-doc (i.e. <<'EOF')."
        echo
        echo -e "    NOTE: The use of quotes around the EOF delimeter is to ensure the shell"
        echo -e "          does not expand any variables within your script."
        echo
        echo -e "        $prog example.com <<'EOF'"
        echo -e "        uptime"
        echo -e "        cat $HOME/.ssh/authorized_keys"
        echo -e "        tail -15 $HOME/.bash_history"
        echo -e "        EOF"
        echo
        echo -e "    ${b}Execute a command concurrently against multiple systems as root${c}"
        echo
        echo -e "        $prog -r -c example-{1..50}.com <<<'cat /etc/shadow'"
        echo
        echo -e "    ${b}Login to a list of servers for manual maintenance${c}"
        echo
        echo -e "        $prog -r example-{1..50}.com <<<'#interact#'"
        echo
        echo -e "    ${b}Edit the same file interactively on each system as root${c}"
        echo
        echo -e "        $prog -r example-{1..50}.com <<<'#interact \"vi /etc/logcheck/logcheck.ignore\"#'"
        echo
        echo -e "    ${b}Execute a custom recipe for running a tripwire update; overriding the"
        echo -e "    default concurrency of 10${c}"
        echo
        echo -e "        $prog -r -c 25 example-{1..50}.com <<<'#tripwire#'"
        echo
        echo -e "    ${b}Change root password followed by tripwire update${c}"
        echo
        echo -e "        $prog -r -c example-{1..50}.com <<'EOF'"
        echo -e "        #passwd#"
        echo -e "        #tripwire#"
        echo -e "        EOF"
        echo
        echo -e "    ${b}Change testuser's password followed by tripwire update${c}"
        echo
        echo -e "        $prog -r -c example-{1..50}.com <<'EOF'"
        echo -e "        #passwd testuser#"
        echo -e "        #tripwire#"
        echo -e "        EOF"
        echo
        echo -e "    ${b}Override timeout period for long running script${c}"
        echo
        echo -e "        $prog example.com <<'EOF'"
        echo -e "        uptime"
        echo -e "        #timeout 25#"
        echo -e "        sleep 20; echo 'sleep complete'"
        echo -e "        EOF"
        echo
        echo -e "${b}COPYRIGHT${c}"
        sed -n '3,16s/^#//p' $0
    fi
}

# print error message followed by usage and exit
error () {
    echo -e "\nERROR: $1\n" >&2
    print_usage >&2
    exit 1
}

# return generated password using provided hostname and pattern
#
# $1 - hostname: string source of letters used during substitution
# $2 - pattern:  root password with the letter 'X' (upper and lower case)
#                when immediately followed by a number being substituded
#                with the appropriate letter from the provided hostname
#                e.g. passAwordeM is derived from:
#                     pattern=passX3wordx1X4
#                     hostname=example.com
get_password () {
    awk -v host="$1" -v pattern="${2-}" '
        function getletter(case_pos) {
            char_case=substr(case_pos, 1, 1)
            pos=substr(case_pos, 2)
            char=substr(host, pos, 1)

            if (char_case == "X") {
                if (char == 1) {
                    return "!"
                } else if (char == 2) {
                    return "@"
                } else if (char == 3) {
                    return "#"
                } else if (char == 4) {
                    return "$"
                } else if (char == 5) {
                    return "%"
                } else if (char == 6) {
                    return "^"
                } else if (char == 7) {
                    return "&"
                } else if (char == 8) {
                    return "*"
                } else if (char == 9) {
                    return "("
                } else if (char == 0) {
                    return ")"
                } else if (char == "-") {
                    return "_"
                } else if (char == ".") {
                    return ">"
                } else {
                    return toupper(char)
                }
            } else {
                return tolower(char)
            }
        }

        BEGIN {
            do {
                idx = match(pattern, /[xX][0-9]/)
                token = substr(pattern, RSTART, RLENGTH)
                letter = getletter(token)
                if (idx != 0) {
                    gsub(token, letter, pattern)
                }
            } while (idx != 0)

            print pattern
        }' | sed -e 's| |\ |g'
}

# collect password patterns from user
get_password_patterns () {
    if $su; then
        echo -n "Enter Root Password Pattern: "
        stty -echo
        read root_password_pattern
        stty echo
        echo
    fi

    if $password_auth; then
        echo -n "Enter Login Password Pattern: "
        stty -echo
        read login_password_pattern
        stty echo
        echo
    fi

    if $sudo; then
        echo -n "Enter SUDO Password Pattern: "
        stty -echo
        read sudo_password_pattern
        stty echo
        echo
    fi

    # extract password prompts from commands
    while read password_prompt; do
        password_prompts+=( "$password_prompt" )
    done < <( awk -F: 'BEGIN {count=0} /^#password.*#$/ {
        if ($3) {
            print substr($0, index($0,$3), length($3)-1)
        } else {
            count++
            print "Enter Password #"count
        }
    }' <<<"$commands" )

    if [[ ${#password_prompts[*]} -gt 0 ]]; then
        # read in password patterns from stdin
        for password_prompt in "${password_prompts[@]}"; do
            echo -n "${password_prompt}: "
            stty -echo
            read password_pattern
            stty echo
            echo

            if [[ "$password_pattern" ]]; then
                password_patterns+=( "$password_pattern" )
            else
                error 'invalid password pattern'
            fi
        done
    fi
}

# convert provided commands into expect commands
insert_commands () {
    local count output

    output="$(mktemp -u -t XXXXX)"
    output="${1}.${output##*/}"
    cp "$1" "$output"
    shift

    count=0

    # print all output if debug is enabled
    if $debug; then
        sed 's/log_user 0/log_user 1/' "$output" > "${output}.tmp"
        mv "${output}.tmp" "$output"
    fi

    # disable logging connect/disconnect if not in verbose mode
    if ! $verbose; then
        sed '/onnect:  /d' "$output" > "${output}.tmp"
        mv "${output}.tmp" "$output"
    fi

    # initial command conversion
    sed '/^#COMMANDS#/ r /dev/stdin' $output > "${output}.tmp" < \
        <(sed -e '/^#/! s_\\\(.\)_\\\\\1_g' \
            -e '/^#/! s_\$_\\$_g' \
            -e '/^#/! s_\"_\\\"_g' \
            -e '/^#/! s_\[_\\[_g' \
            -e '/^#/! s_(_\(_g' \
            -e '/^#/! s_^_expect -re $prompt;send "_' \
            -e '/^#/! s_$_\\r"_' \
            -e 's_^#timeout#$_expect -re $prompt;set timeout 20;send "\\r"_' \
            -e 's_^#\(timeout .*\)#_expect -re $prompt;set \1;send "\\r"_' \
            -e 's_^#\(expect .*\)#.*_\1_' \
            <<<"$commands")
    sed '/^#COMMANDS#/d' "${output}.tmp" > "$output"

    # replace #password# token with expect code
    count=4
    while grep -q '^#password' "$output"; do
        read line password_count <<<$(awk -F: '/^#password/ {if ($2) {print NR,$2} else {print NR,1}; exit}' "$output")
        password_count=${password_count%#}

        # remove password token
        sed "$line r /dev/stdin" "$output" > "${output}.tmp" < <(
            echo "set password${count} \"#password${count}#\""
            for i in $(eval "echo {1..$password_count}"); do
                echo 'sleep 1'
                echo "send \"\$password${count}\r\""
            done
        )

        sed "${line}d" "${output}.tmp" > "$output"
        ((count+=1))
    done

    # expand built-in #interact# token; performed here instead of in parse_tokens for access to hostname
    while read line args <<<$(grep -n "^#interact" "$output" | head -1 | sed -e 's/:#interact\(.*\)/\1/' -e 's/#$//'); do
        # if no tokens are found we're done
        [[ -z "$line" ]] && break

        interactive=true

        # remove leading and trailing quotes while escaping double quotes
        args=$(sed -e "s/^'//" -e "s/'$//" -e 's/^"//' -e 's/"$//' -e 's/"/\\"/g' <<<"$args")

        # replace #interact# token with expect code
        sed "$line r /dev/stdin" "$output" > "${output}.tmp" <<INTERACT
send_user "\n\n                   ##      Entering Interactive Mode      ##\n"
send_user "                   ### type \"#x\" to end your interaction ###\n"
send "\r"
expect -re \$prompt
send "$args\r"
expect *
interact {
    \#x {
        send_user "\n\n                   ##      Exiting Interactive Mode       ##\n"
        # send ctrl-c to force a prompt
        send \003
        return
    }
    -o eof {
        send_user "\n\n                   #  Aborted! - User Disconnected During Interact: \$host  #\n"
        exit
    }
}
INTERACT

        sed "${line}d" "${output}.tmp" > "$output"
    done

    cat <(insert_expect_args "${output}" "$@")

    rm -f "${output}"*
}

# insert passwords into expect script
insert_expect_args () {
    local count host password output

    output="$(mktemp -u -t XXXXX)"
    output="${1}.${output##*/}"
    cp "$1" "$output"
    shift

    sed "s|#username#|$1|g" "$output" > "${output}.tmp"
    shift

    sed "s|#host#|$1|g" "${output}.tmp" > "$output"
    host="$1"
    shift

    count=1
    while [[ $# -gt 0 ]]; do
        password=$(get_password "$host" "${1-}")
        password="${password//\"/\\\\\"}"
        password="${password//\$/\\\\\$}"
        sed "s|#password$count#|$password|g" "$output" > "${output}.tmp"
        cat "${output}.tmp" > "$output"
        ((count+=1))
        shift
    done

    cat "$output"

    rm -f "${output}"*
}

# initialize ssh agent
ssh_agent_init () {
    echo -e "\nINITIALIZING SSH AGENT" >&2

    eval $(ssh-agent | sed '/echo Agent/d')

    # load all dsa & rsa keys (excluding symlinks)
    for key in $HOME/.ssh/*_?sa; do
        [[ ! -h "$key" ]] && ssh-add "$key"
    done
}

# destroy ssh agent
ssh_agent_destroy () {
    if kill $SSH_AGENT_PID 2>/dev/null; then
        echo -e "\nDESTROYING SSH AGENT" >&2
        export SSH_AGENT_PID=
        export SSH_AUTH_SOCK=
    fi
}

# parse tokens from commands
parse_tokens () {
    local commands_file line tokens user

    tokens=( )
    commands_file="$tmp_dir/commands"

    echo "$commands" > "$commands_file"

    if [[ -d "$recipes_dir" ]]; then
        # load user defined tokens
        tokens=
        for token_file in $recipes_dir/*; do
            if [[ -r "$token_file" ]]; then
                if [[ "$tokens" ]]; then
                    tokens="${tokens}|^#${token_file##*/}"
                else
                    tokens="^#${token_file##*/}"
                fi
            fi
        done

        # expand user defined tokens
        if [[ "$tokens" ]]; then
            while read token args <<<$(egrep -n "$tokens" "$commands_file" | head -1 | sed -e 's/#\(.*\)/\1/' -e 's/#$//'); do
                # if no tokens are found we're done
                [[ -z "$token" ]] && break

                read line token <<<$(sed 's/:/ /' <<<"$token")

                # load recipe from associated token file
                recipe=$(cat "${recipes_dir}/$token")

                # replace args within recipe
                count=1
                while read arg; do
                    recipe=$(sed "s/\$arg${count}/$arg/g" <<<"$recipe")
                    ((count+=1))
                done < <(eval "for arg in $args; do echo \$arg; done")

                # sanity check for missing args
                grep -q '$arg[[:digit:]]' <<<"$recipe" && { echo "ERROR: missing argument for token: $token"; exit 1; }

                # replace token with associated recipe
                sed "$line r /dev/stdin" "$commands_file" > "${commands_file}.tmp" <<<"$recipe"

                # remove token
                sed "${line}d" "${commands_file}.tmp" > "$commands_file"
            done
        fi
    fi

    # expand built-in #passwd# token
    while grep -q '^#passwd' "$commands_file"; do
        read line user <<<$(awk '/^#passwd/ {if ($2) {print NR,substr($0, index($0,$2), length($2)-1)} else {print NR,"root"}; exit}' "$commands_file")

        # insert shell commands for password change
        sed "$line r /dev/stdin" "$commands_file" > "${commands_file}.tmp" <<PASSWD
passwd $user
#password:2:Enter new password for $user#
PASSWD

        # remove passwd token
        sed "${line}d" "${commands_file}.tmp" > "$commands_file"
    done

    # expand built-in #user# token
    commands=$(sed "s/#user#/$username/" "$commands_file")

    rm -f $commands_file{,.tmp}
}

# execute expect script against provided host
#
# NOTE: if you attempt to connect to the same host multiple times
#       concurrently, you will likely see failures due to the speed
#       in which the connections are attempted
#
# $1 - host - the host to run script against
run_hosts () {
    local count host logger_pid passwords total prev_batch batch finished running

    batch=1
    count=1
    total=$#

    # determine batch number if outputting to existing directory
    if [[ -n "$output_dir" ]]; then
        prev_batch=$(ls -1 "$output_dir" | tail -n1)
        [[ -n "$prev_batch" ]] && batch=$(expr ${prev_batch%%x*} + 1)
    fi

    [[ $batch -lt 10 ]] && batch="0${batch}"

    # watch for finished host output to print to stdout
    if [[ $concurrency -gt 1 ]]; then
        # check root password on first host before we hit everyone with an incorrect password
        if $su || $sudo; then
            echo -en '\n\n                   # Validating Root Password...'
            cat <(insert_expect_args "$script" "$username" "$1" "${root_password_pattern-}" "${sudo_password_pattern-}" "${login_password_pattern-}") | sed '/#COMMANDS#/d' | expect - > /dev/null 2>&1
            if [[ $? -ne 0 ]]; then
                echo -e 'FAILED #\n'
                echo "ABORT: Failed to authenticate as root on host: $1"
                exit 1
            else
                echo -e 'OK #\n'
            fi
        fi

        # spawn thread to handle output of finished jobs
        {
            finished_count=1
            finished_output_logs=

            # load expected log files in original order
            for host in "${hosts[@]}"; do
                if [[ $finished_count -ge 10 ]]; then
                    output_log="${tmp_dir}/${batch}x${finished_count}-${host}.log"
                else
                    output_log="${tmp_dir}/${batch}x0${finished_count}-${host}.log"
                fi

                finished_output_logs=(${finished_output_logs[@]} "$output_log")

                ((finished_count+=1))
            done
            finished_count=1


            while [[ $finished_count -le $total ]]; do
                sleep 1

                # look for finished log file from next host
                while [[ -r "${finished_output_logs[0]}" ]]; do
                    file="${finished_output_logs[0]}"

                    # pop finished log off stack
                    unset finished_output_logs[0]
                    finished_output_logs=("${finished_output_logs[@]-}")

                    ! $quiet && ! $silent && cat "$file"

                    if [[ -n "$output_dir" ]]; then
                        strip_color_codes "$file"
                        output="${output_dir}/${file##*/}"
                        mv "$file" "${output%.log}"
                    else
                        rm -f "$file"
                    fi

                    ((finished_count+=1))
                done
            done
        } &

       logger_pid=$!
    fi

    while [[ $# -gt 0 ]]; do
        passwords=( )
        host="$1"

        if [[ $count -ge 10 ]]; then
            output="${batch}x${count}-${host}"
        else
            output="${batch}x0${count}-${host}"
        fi

        if [[ $concurrency -gt 1 ]]; then
            running=$(jobs -p | grep -v $logger_pid | wc -l)

            if [[ $running -lt $concurrency ]]; then
                $debug || $quiet && echo -e "\nSpawning job $count of $total for $host" |  tr '[:lower:]' '[:upper:]' >&2

                {
                    jobnum=$count

                    # convert patterns to host based passwords
                    if [[ ${#password_patterns[*]} -gt 0 ]]; then
                        for pattern in "${password_patterns[@]}"; do
                            passwords+=( "$(get_password $host "${pattern-}")" )
                        done
                    fi

                    # run expect script via stdin to avoid passwords being exposed via ps
                    expect -f <(insert_commands "$script" "$username" "$host" "${root_password_pattern-}" "${sudo_password_pattern-}" "${login_password_pattern-}" "${passwords[@]-}") > "${tmp_dir}/${output}.running"

                    # insert white space following host disconnect
                    $verbose || echo -e '\n' >> "${tmp_dir}/${output}.running"

                    $debug || $quiet && echo -e "\nJob $jobnum of $total Completed" |  tr '[:lower:]' '[:upper:]' >&2

                    mv "${tmp_dir}/${output}.running" "${tmp_dir}/${output}.log"
                } &

                ((count+=1))
                shift
            fi
        else
            $debug || $quiet && echo -e "\nSpawning job $count of $total for $host" |  tr '[:lower:]' '[:upper:]' >&2

            # convert patterns to host based passwords
            if [[ ${#password_patterns[*]} -gt 0 ]]; then
                for pattern in "${password_patterns[@]}"; do
                    passwords+=( "$(get_password $host "${pattern-}")" )
                done
            fi

            # run expect script via stdin to avoid passwords being exposed via ps
            if ! $interactive; then
                expect -f <(insert_commands "$script" "$username" "$host" "${root_password_pattern-}" "${sudo_password_pattern-}" "${login_password_pattern-}" "${passwords[@]-}") | tee -a "${tmp_dir}/${output}.running"

                [[ $? -eq 2 ]] && { echo "ABORT: Failed to authenticate as root on host: $host"; exit 1; }

                # insert white space following host disconnect
                $verbose || echo -e '\n' | tee -a "${tmp_dir}/${output}.running"

                if [[ -n "$output_dir" ]]; then
                    strip_color_codes "${tmp_dir}/${output}.running"
                    mv "${tmp_dir}/${output}.running" "${output_dir}/${output}"
                fi
            else
                expect -f <(insert_commands "$script" "$username" "$host" "${root_password_pattern-}" "${sudo_password_pattern-}" "${login_password_pattern-}" "${passwords[@]-}")
                [[ $? -eq 2 ]] && { echo "ABORT: Failed to authenticate as root on host: $host"; exit 1; }
                echo
            fi

            $debug || $quiet && echo -e "\nJob $count of $total Completed" |  tr '[:lower:]' '[:upper:]' >&2

            ((count+=1))
            shift
        fi
    done

    wait
}

# strip color codes from input file
#
# $1 - file - the file to strip color codes from
strip_color_codes () {
    # detect sed extended regular expression option
    if sed -? 2>&1 | grep -q ' -r'; then
        sed -r -e 's/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g' -e 's/^\x1B\]0;.*\a//' -e 's/# \^C/#/g' -e 's/\r$//' "$1" >> "${1}.tmp"
    else
        sed -E -e 's/\x1B\[([0-9]{1,2}(;[0-9]{1,2})?)?[m|K]//g' -e 's/^\x1B\]0;.*\a//' -e 's/# \^C/#/g' -e 's/\r$//' "$1" >> "${1}.tmp"
    fi

    mv "${1}.tmp" "$1"
}


# process arguments
for arg in $@; do
    case "$arg" in
        -c)
            concurrency='-c'
            ;;
        -c[0-9]*)
            concurrency=${arg#-c}
            ;;
        -d)
            debug=true
            verbose=true
            ;;
        -h)
            print_usage 'verbose' >&2
            exit 0
            ;;
        --help)
            print_usage 'pretty' | less -R
            exit 0
            ;;
        -i)
            interactive=true
            commands='#interact#'
            ;;
        -o)
            output_file='-o'
            ;;
        -O)
            output_dir='-O'
            ;;
        -p)
            ssh_agent=true
            password_auth=true
            ;;
        -P)
            ssh_agent=false
            password_auth=true
            ;;
        -q)
            quiet=true
            ;;
        -Q)
            quiet=true
            silent=true
            ;;
        -r)
            $sudo && error 'cannot combine -R with -r'
            su=true
            ;;
        -R)
            $su && error 'cannot combine -r with -R'
            sudo=true
            ;;
        -f)
            commands='-f'
            ;;
        -F)
            hosts=( '-F' )
            ;;
        -u)
            username='-u'
            ;;
        -v)
            echo $prog $version
            exit 0
            ;;
        -V)
            verbose=true
            ;;
         *)
            if [[ "$concurrency" == '-c' ]] && [[ "$arg" =~ ^[0-9]+$ ]]; then
                concurrency=$arg
            elif [[ "$commands" == '-f' ]]; then
                [[ ! -r "$arg" ]] && error 'cannot read provided command file'
                commands=$(cat "$arg")
            elif [[ ${#hosts[*]} -ne 0 && "${hosts[0]}" == '-F' ]]; then
                [[ ! -r "$arg" ]] && error 'cannot read provided hosts file'
                hosts=( $(tr '\n' ' ' < "$arg") )
            elif [[ "$output_file" == '-o' ]]; then
                output_file="$HOME/ssh-exec.$(date +%Y%m%d_%H%M%S)"
                hosts+=( "$arg" )
            elif [[ "$output_dir" == '-O' ]]; then
                output_dir="$HOME/ssh-exec.$(date +%Y%m%d)"
                [[ -f "$output_dir" ]] && { echo "ERROR: file already exists with name '$output_dir'"; exit 1; }
                hosts+=( "$arg" )
                mkdir -p "$output_dir"
            elif [[ "$username" == '-u' ]]; then
                username="$arg"
            else
                hosts+=( "$arg" )
            fi
            ;;
    esac
done

# sanity check
[[ ${#hosts[*]} -eq 0 || "${hosts[0]}" == '-F' ]] && error 'no hosts provided'
[[ "$commands" == '-f' ]] && error 'no commands provided'

# set default concurrecy if number was not provided
[[ "$concurrency" == '-c' ]] && concurrency=10

# overide concurrency if only one host is provided
[[ ${#hosts[*]} -eq 1 ]] && [[ "$concurrency" -gt 1 ]] && concurrency=1

# set default username if none was provided
[[ "$username" == '-u' ]] && username=$USER

# capture commands from stdin
if [[ -z "$commands" ]]; then
    stdin=$(cat <&0)

    if [[ "$stdin" ]]; then
        commands="$stdin"
    elif [[ -z "$stdin" ]]; then
        error 'no commands provided'
    fi
fi

# parse tokens within commands
parse_tokens

# sanity check
if grep -q '^#interact#' <<<"$commands"; then
    [[ $concurrency -gt 1 ]] && error '#interact# is not allowed when combined with concurrency'
    [[ -n "$output_dir" ]] && error '#interact# is not allowed when combined with -O'
    [[ "$output_file" != '/dev/null' ]] && error '#interact# is not allowed when combined with -o'
fi

# check for active ssh-agent
if $ssh_agent && ! ssh-add -l >/dev/null 2>&1; then
    load_ssh_agent=true
fi

# prompt user to continue
{
    if $su || $sudo; then
        echo -e "\nCOMMANDS (run as root):\n"
    else
        echo -e "\nCOMMANDS (run as $username):\n"
    fi

    while read cmd;  do
        echo -e "\t$cmd"
    done <<<"$commands"

    if [[ ${#hosts[*]} -gt 1 ]]; then
        if [[ $concurrency -gt 1 ]]; then
            echo -e "\nHOSTS (up to $concurrency systems executed concurrently):"
        else
            echo -e "\nHOSTS (executed incrementally):"
        fi

        for host in "${hosts[@]}"; do
            echo -e "\t$host"
        done
    else
        echo -e "\nHOST:\t${hosts[*]}"
    fi

    if $load_ssh_agent; then
        echo -e '\nNOTE:'
        echo -e '\tYou currently do not have any keys loaded into an ssh agent.'
        echo
        echo -e '\tIf you choose to continue an agent will be started for you.'
        echo
        echo -e '\tYou will then be prompted to enter the passphrase for any keys'
        echo -e '\tfound in your ~/.ssh directory.'
        echo
        echo -e '\tNote: You only need to provide the passphrase for the key'
        echo -e '\t      necessary for the servers you are executing against.'
        echo
        echo -e '\t      Simply hitting "Enter" when prompted for an unnecessary'
        echo -e '\t      key is sufficient to skip loading that key.'
        echo
        echo -e '\tThis agent will be destroyed when ssh-exec exits.'
    fi

    if [[ -n "$output_dir" ]]; then
        echo -e '\nNOTE:'
        echo -e "\tEach server's output will be saved to a separate file in:\n\t\t$output_dir"
    fi

    if [[ "$output_file" != '/dev/null' ]]; then
        echo -e '\nNOTE:'
        echo -e "\tAll server output will be saved to:\n\t\t$output_file"
    fi

    warnings=( )
    # hand-holding: check for password change without password being provided
    if ! grep -q '^#password:2' <<<"$commands"; then
        if grep -q 'passwd' <<<"$commands" && ! grep -q '-' <<<"$commands"; then
            warnings+=("passwd will require the #password:2# token\n\t\t- you may want to consider using the builtin #passwd <username># token instead")
        fi
    fi

    # hand-holding: check for rm -rf
    if grep -q 'rm -rf /' <<<"$commands"; then
        warnings+=("rm -rf can be dangerous when automated!\n\t  make sure you double check the commands above before continuing")
    fi

    # hand-holding: check for no logging of output
    if $quiet && [[ "$output_file" == '/dev/null' ]] && [[ -z "$output_dir" ]]; then
        warnings+=("System output to screen has been disabled AND you are not saving the output to a file!\n\tBy continuing you are executing commands with no way of knowing their results.\n\tThis is NOT advised!")
    fi

    if [[ ${#warnings[*]} -gt 0 ]]; then
        echo -e '\nWARNINGS:'
        for warning in "${warnings[@]}"; do
            echo -e "\t* $warning\n"
        done
    fi
} | tee -a "$output_file"

# flush stdin before prompting to continue
0<&-
exec 0</dev/tty

echo -e -n "\nAre you sure you want to continue [y/N]? "
read continue

if [[ ! "$continue" =~ y|Y ]]; then
    echo 'Aborted!'
    exit 0
fi

# load ssh-agent
$load_ssh_agent && ssh_agent_init

# collect password patterns from user
get_password_patterns

# run expect script against all provided hosts
if $silent; then
    run_hosts ${hosts[@]} > "$output_file" 2>/dev/null
elif $quiet; then
    run_hosts ${hosts[@]} > "$output_file"
elif $interactive; then
    run_hosts ${hosts[@]}
else
    run_hosts ${hosts[@]} | tee -a "${output_file}"
    [[ "$output_file" != '/dev/null' ]] && strip_color_codes "${output_file}"
fi

exit 0

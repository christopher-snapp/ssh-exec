#!/bin/bash
#
# Copyright (C) 2011, Christopher A. Snapp <snappca@gmail.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# enable strict error checking
set -ue

# os check
[[ "$(uname -s)" != 'SunOs' ]] || { echo 'ERROR: this script is known not to work on Solaris'; exit 1; }

# dependency check
[[ "$(which expect)" ]] || { echo 'ERROR: expect command is not available'; exit 1; }

prog=$(basename $0)
version=0.9.8

commands=
password_patterns=( )
password_prompts=( )
hosts=( )
su_do=false

tmp_dir="$(mktemp -dt $prog.XXXXX)" || error 'cannot create temp directory!'
script="${tmp_dir}/commands.exp"

trap "rm -rf $tmp_dir;exit;" EXIT
trap 'stty echo;rm -rf $tmp_dir;echo -e "\nAborted!";exit;' INT TERM

# initialize expect script used during ssh session
cat > "$script" <<'EXPECT'
#!/usr/bin/expect
set timeout 10
set prompt "(>|%|#|\\$) $"
set host [lindex $argv 0]

log_user 0

spawn -noecho ssh $host
set connected 1

expect_after {
    timeout {
        send_user "\n\n                   #  Aborted! - Timeout Looking for Prompt: $host  #\n"
        return
    } default {
        send_user "\n\n                   #  Aborted! - Error State Observed: $host  #\n"
        return
    }
}

# user login
expect "*nter passphrase" {
    send_user "\n\n                   #  Aborted! - Missing Passphrase: $host  #\n"
    return
} "*yes/no" {
    send_user "\n\n                   # Accepting Authenticity: $host #\n"
    send "yes\r"
    expect -re $prompt {
        send_user "\n\n                   #       Connect:    $host      #\n"
        send "\r"
        log_user 1
    }
} -re $prompt {
    send_user "\n\n                   #       Connect:    $host      #\n"
    send "\r"
    log_user 1
}

# SUDO: LOGIN #
set password1 [lindex $argv 1]
sleep 1
send "su -\r"
expect "*sword:" {
    send "$password1\r"
    expect "su: *" {
        send "exit\r"
        send_user "\n\n                   #  Aborted! - Invalid Root Password: $host  #\n"
        exit
    } -re $prompt {
        # send ctrl-c to force a prompt
        send \003
# SUDO: LOGIN #

#COMMANDS#

# SUDO: LOGOUT #
        expect -re $prompt
        log_user 0
        # exiting root session
        send "exit\r"
    }
}
# SUDO: LOGOUT #

if {$connected} {
    sleep 1
    expect -re $prompt
    log_user 0
    send "exit\r"
    send_user "\n\n                   #       Disconnect: $host      #\n"
}
EXPECT


# print command usage
#
# $1 - boolean determining if full formatted output should be printed
print_usage () {
    local verbose b u c

    verbose=false
    [[ $# -gt 0 ]] && verbose=true

    b='\033[1m'
    u='\033[4m'
    c='\033[0m'

    if $verbose; then
        echo "$prog $version" | tr '[:lower:]' '[:upper:]'
        echo
        echo -e "${b}NAME${c}"
        echo -e "\t${b}$prog${c} â€” executes commands on remote hosts; optionally as root"
        echo
    fi

    echo -e "${b}SYNOPSIS${c}"
    echo -e "\t${b}$prog${c} [${b}-hr${c}] [${b}-f${c} ${u}file${c}] ${u}host1..host2..${c}"
    echo

    if $verbose; then
        echo -e "${b}DESCRIPTION${c}"
        echo -e "\tThe primary goal of this script is to provide a secure method"
        echo -e "\tfor executing commands on remote hosts as root without sudo."
        echo
        echo -e "\tNote that commands can be provided via file or STDIN."
        echo
        echo -e "\t${b}Running as Root${c}"
        echo -e "\tRunning as root will require that a root password be "
        echo -e "\tprovided as a pattern where the letter 'X' (upper or lower case)"
        echo -e "\twhen immediately followed by a number will be substituted"
        echo -e "\twith the appropriate letter from the provided hostname."
        echo
        echo -e "\tExample:\t pattern: ${b}passX3wordx1X4${c}"
        echo -e "\t\t\thostname: ${b}example.com${c}"
        echo -e "\t\t\t  result: ${b}passAwordeM${c}"
        echo
        echo -e "\t${b}Troubleshooting${c}"
        echo -e "\tIt is expected that the results of your script end"
        echo -e "\twith a prompt as recognized by the regular expression:"
        echo
        echo -e "\t\t\t${b}/(>|%|#|\\$) \$/${c}"
        echo
        echo -e "\tYour script will hang should the prompt not be detected."
        echo
    fi

    echo -e "${b}OPTIONS${c}"
    echo -e "\t${b}-f${c} ${u}file${c}"
    echo -e "\t\tthe file containing commands to be executed"
    echo
    echo -e "\t${b}-h${c}\tdisplay this help and exit"
    echo
    echo -e "\t${b}-r${c}\trun commands as root"
    echo
}

# print error message followed by usage and exit
error () {
    echo -e "\nERROR: $1\n" >&2
    print_usage >&2
    exit 1
}

# return generated password using provided hostname and pattern
#
# $1 - hostname: string source of letters used during substitution
# $2 - pattern:  root password with the letter 'X' (upper and lower case)
#                when immediately followed by a number being substituded
#                with the appropriate letter from the provided hostname
#                e.g. passAwordeM is derived from:
#                     pattern=passX3wordx1X4
#                     hostname=example.com
get_password () {
    awk -v host="$1" -v pattern="$2" '
        function getletter(case_pos) {
            case=substr(case_pos, 1, 1)
            pos=substr(case_pos, 2)
            char=(case == "X") ? toupper(substr(host, pos, 1)) : tolower(substr(host, pos, 1))

            if (char == 1) {
                return "!"
            } else if (char == 2) {
                return "@"
            } else if (char == 3) {
                return "#"
            } else if (char == 4) {
                return "$"
            } else if (char == 5) {
                return "%"
            } else if (char == 6) {
                return "^"
            } else if (char == 7) {
                return "&"
            } else if (char == 8) {
                return "*"
            } else if (char == 9) {
                return "("
            } else if (char == 0) {
                return ")"
            } else if (char == "-") {
                return "_"
            } else if (char == ".") {
                return ">"
            } else {
                return char
            }
        }

        BEGIN {
            do {
                idx = match(pattern, /[xX][0-9]/)
                token = substr(pattern, RSTART, RLENGTH)
                letter = getletter(token)
                if (idx != 0) {
                    gsub(token, letter, pattern)
                }
            } while (idx != 0)

            print pattern
        }'
}

# collect password patterns from user
get_password_patterns () {
    # extract password prompts from commands
    while read password_prompt; do
        password_prompts+=( "$password_prompt" )
    done < <( awk -F: 'BEGIN {count=0} /^#password.*#$/ {
        if ($3) {
            print substr($0, index($0,$3), length($3)-1)
        } else {
            count++
            print "Enter Password #"count
        }
    }' <<<"$commands" )

    if [[ ${#password_prompts[*]} -gt 0 ]]; then
        # read in password patterns from stdin
        for password_prompt in "${password_prompts[@]}"; do
            echo -n "${password_prompt}: "
            stty -echo
            read password_pattern
            stty echo
            echo

            if [[ "$password_pattern" ]]; then
                password_patterns+=( "$password_pattern" )
            else
                error 'invalid password pattern'
            fi
        done
    fi
}

# convert provided commands into expect commands
generate_script () {
    # remove su code from expect script
    if ! $su_do; then
        sed '/SUDO: LO/,/SUDO: LO/d' "$script" > "${script}.tmp"
        mv "${script}.tmp" "$script"
    fi

    # initial command conversion
    sed '/^#COMMANDS#/ r /dev/stdin' $script > "${script}.tmp" < \
        <(sed -e '/^#/! s_\\\(.\)_\\\\\1_g' \
            -e '/^#/! s_\$_\\$_g' \
            -e '/^#/! s_\"_\\\"_g' \
            -e '/^#/! s_\[_\\[_g' \
            -e '/^#/! s_(_\(_g' \
            -e '/^#/! s_^_expect -re $prompt;send "_' \
            -e '/^#/! s_$_\\r"_' \
            -e 's_^#\(timeout .*\)#.*_set \1_' \
            -e 's_^#\(expect .*\)#.*_\1_' \
            <<<"$commands")
    sed '/^#COMMANDS#/d' "${script}.tmp" > "$script"

    # replace #interact# token with expect code
    sed '/^#interact#/ r /dev/stdin' $script > "${script}.tmp" <<'INTERACT'
send_user "\n\n                   ##      Entering Interactive Mode      ##\n"
send_user "                   ### type \"#x\" to end your interaction ###\n"
send "\r"
expect -re $prompt
interact {
    \#x {
        send_user "\n\n                   ##      Exiting Interactive Mode       ##\n"
        return
    }
    -o eof {
        send_user "\n\n                   #  Aborted! - User Disconnected During Interact: $host  #\n"
        exit
    }
}
INTERACT

    # remove interact token
    sed '/^#interact/d' "${script}.tmp" > "$script"

    # shift expect args if root password is provided
    $su_do && count=1

    # replace #password# token with expect code
    while grep -q '^#password' "$script"; do
        read line password_count <<<$(awk -F: '/^#password/ {if ($2) {print NR,$2} else {print NR,1}; exit}' "$script")
        count=$(( $count+1 ))
        password_count=${password_count%#}

        # remove password token
        sed "$line r /dev/stdin" "$script" > "${script}.tmp" < <(
            echo "set password${count} [lindex \$argv $count]"
            for i in $(eval "echo {1..$password_count}"); do
                echo 'sleep 1'
                echo "send \"\$password${count}\r\""
            done
        )

        sed "${line}d" "${script}.tmp" > "$script"
    done

    rm -f "${script}.tmp"
}

# sanity check
[[ $# -lt 1 ]] && error 'not enough arguments provided'

# process arguments
for arg in $@; do
    case "$arg" in
        -h)
            print_usage 'verbose' >&2
            exit 0
            ;;
        -r)
            su_do=true
            password_prompts=( "Enter Root Password Pattern" )
            ;;
        -f)
            commands='-f'
            ;;
         *)
            if [[ "$commands" != '-f' ]]; then
                hosts+=( "$arg" )
            else
                [[ ! -r "$arg" ]] && error 'cannot read provided command file'
                commands=$(cat "$arg")
            fi
            ;;
    esac
done

# sanity check
[[ ${#hosts[*]} -eq 0 ]] && error 'no hosts provided'

# capture commands from stdin
if [[ -z "$commands" ]]; then
    stdin=$(cat <&0)

    if [[ "$stdin" ]]; then
        commands="$stdin"
    elif [[ -z "$stdin" ]]; then
        error 'no commands provided'
    fi
fi

# prompt user to continue
echo -e "\nCOMMANDS:"
while read cmd;  do
    echo -e "\t$cmd"
done <<<"$commands"

echo -e "\nHOSTS:"
for host in "${hosts[@]}"; do
    echo -e "\t$host"
done

# flush stdin before prompting to continue
0<&-
exec 0</dev/tty

echo -e -n "\nAre you sure you want to continue [y/N]? "
read continue
if [[ ! "$continue" =~ y|Y ]]; then
    echo 'Aborted!'
    exit 0
fi

# collect password patterns from user
get_password_patterns

# convert shell commands into expect script
generate_script

# run generated script against all provided hosts
for host in "${hosts[@]}"; do
    passwords=( )

    trap 'rm -rf $tmp_dir;echo -e "\nAborted!";break;exit;'  INT TERM

    # run script if host is available
    if ping -qn -c1 "$host" 2>&1 | grep -q '1.*received'; then
        # convert patterns to host based passwords
        if [[ ${#password_patterns[*]} -gt 0 ]]; then
            for pattern in "${password_patterns[@]}"; do
                passwords+=( $(get_password $host $pattern) )
            done
        fi

       expect -f "$script" "$host" "${passwords[@]-}"
    else
        echo -e "\n$(echo "#   $host Unavailable   #" | tr '[:lower:]' '[:upper:]')"
        continue
    fi
done

exit 0
